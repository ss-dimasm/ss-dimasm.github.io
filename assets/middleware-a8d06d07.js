function H(c,d){let a;try{a=c()}catch{return}return{getItem:s=>{var e;const m=h=>h===null?null:JSON.parse(h,d==null?void 0:d.reviver),v=(e=a.getItem(s))!=null?e:null;return v instanceof Promise?v.then(m):m(v)},setItem:(s,e)=>a.setItem(s,JSON.stringify(e,d==null?void 0:d.replacer)),removeItem:s=>a.removeItem(s)}}const I=c=>d=>{try{const a=c(d);return a instanceof Promise?a:{then(o){return I(o)(a)},catch(o){return this}}}catch(a){return{then(o){return this},catch(o){return I(o)(a)}}}},R=(c,d)=>(a,o,s)=>{let e={getStorage:()=>localStorage,serialize:JSON.stringify,deserialize:JSON.parse,partialize:r=>r,version:0,merge:(r,l)=>({...l,...r}),...d},m=!1;const v=new Set,h=new Set;let i;try{i=e.getStorage()}catch{}if(!i)return c((...r)=>{console.warn(`[zustand persist middleware] Unable to update item '${e.name}', the given storage is currently unavailable.`),a(...r)},o,s);const S=I(e.serialize),p=()=>{const r=e.partialize({...o()});let l;const t=S({state:r,version:e.version}).then(u=>i.setItem(e.name,u)).catch(u=>{l=u});if(l)throw l;return t},y=s.setState;s.setState=(r,l)=>{y(r,l),p()};const f=c((...r)=>{a(...r),p()},o,s);let g;const n=()=>{var r;if(!i)return;m=!1,v.forEach(t=>t(o()));const l=((r=e.onRehydrateStorage)==null?void 0:r.call(e,o()))||void 0;return I(i.getItem.bind(i))(e.name).then(t=>{if(t)return e.deserialize(t)}).then(t=>{if(t)if(typeof t.version=="number"&&t.version!==e.version){if(e.migrate)return e.migrate(t.state,t.version);console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}else return t.state}).then(t=>{var u;return g=e.merge(t,(u=o())!=null?u:f),a(g,!0),p()}).then(()=>{l==null||l(g,void 0),m=!0,h.forEach(t=>t(g))}).catch(t=>{l==null||l(void 0,t)})};return s.persist={setOptions:r=>{e={...e,...r},r.getStorage&&(i=r.getStorage())},clearStorage:()=>{i==null||i.removeItem(e.name)},getOptions:()=>e,rehydrate:()=>n(),hasHydrated:()=>m,onHydrate:r=>(v.add(r),()=>{v.delete(r)}),onFinishHydration:r=>(h.add(r),()=>{h.delete(r)})},n(),g||f},E=(c,d)=>(a,o,s)=>{let e={storage:H(()=>localStorage),partialize:n=>n,version:0,merge:(n,r)=>({...r,...n}),...d},m=!1;const v=new Set,h=new Set;let i=e.storage;if(!i)return c((...n)=>{console.warn(`[zustand persist middleware] Unable to update item '${e.name}', the given storage is currently unavailable.`),a(...n)},o,s);const S=()=>{const n=e.partialize({...o()});return i.setItem(e.name,{state:n,version:e.version})},p=s.setState;s.setState=(n,r)=>{p(n,r),S()};const y=c((...n)=>{a(...n),S()},o,s);let f;const g=()=>{var n,r;if(!i)return;m=!1,v.forEach(t=>{var u;return t((u=o())!=null?u:y)});const l=((r=e.onRehydrateStorage)==null?void 0:r.call(e,(n=o())!=null?n:y))||void 0;return I(i.getItem.bind(i))(e.name).then(t=>{if(t)if(typeof t.version=="number"&&t.version!==e.version){if(e.migrate)return e.migrate(t.state,t.version);console.error("State loaded from storage couldn't be migrated since no migrate function was provided")}else return t.state}).then(t=>{var u;return f=e.merge(t,(u=o())!=null?u:y),a(f,!0),S()}).then(()=>{l==null||l(f,void 0),f=o(),m=!0,h.forEach(t=>t(f))}).catch(t=>{l==null||l(void 0,t)})};return s.persist={setOptions:n=>{e={...e,...n},n.storage&&(i=n.storage)},clearStorage:()=>{i==null||i.removeItem(e.name)},getOptions:()=>e,rehydrate:()=>g(),hasHydrated:()=>m,onHydrate:n=>(v.add(n),()=>{v.delete(n)}),onFinishHydration:n=>(h.add(n),()=>{h.delete(n)})},e.skipHydration||g(),f||y},_=(c,d)=>"getStorage"in d||"serialize"in d||"deserialize"in d?R(c,d):E(c,d),w=_;export{w as p};
